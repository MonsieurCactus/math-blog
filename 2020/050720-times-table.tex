\documentclass[12pt]{article}
%Gumm{\color{blue}i}|065|=)
\usepackage{amsmath, amsfonts, amssymb}
\usepackage[margin=0.5in]{geometry}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}

\usepackage{fontspec}
\usepackage{xcolor}

\newcommand{\off}[1]{}
\DeclareMathSizes{20}{30}{20}{18}
\usepackage{tikz}

%\setmainfont[Color=brown]{Linux Libertine}


\title{Tune-Up: Times Tables}
\date{}
\begin{document}

\sffamily

\maketitle

{\fontsize{16pt}{16pt}\selectfont 

\noindent  \textbf{Problem Statement} \\ \\
If you consider $N$ randomly chosen integers from $1$ to $x$  - - - $N$ random elements of the set $\{ 1, 2, \dots x\}$ - - - how large should $N$ be so that with high probability we can take a bunch of the numbers we have just chosen, multiply them and get a perfect square? \\ \\
\textbf{Goal} Factor large integers. \\ \\
\noindent This is a difficult problem to resolve.  Let's choose $x = 100$ and $N = 5$ there are $\binom{x}{N} = \binom{100}{5}  < 100^5 = 10^{10} $.  The exact number of $5$ element subsets of $\{ 1, \dots, 100\}$ is 
$$ \# \{ subsets\} = \binom{100}{5} = \frac{100 \times 99 \times 98 \times 97 \times 96}{5 \times 4 \times 3 \times 2 \times 1} = 75287052.0 \approx   7.5 \times 10^8 $$
The symbol we are using ``$\approx$" deserves a lot of qualitifcation given the level of journal we are reading there.  There are many possible notions of ``closeness" we could define here, example: [agree in the first 3 digits, so that $300 \approx 30.0$.]  This is a silly notion of closeness yet if we do enough consistency checks, this too could also be viable. \\ \\
The set of subsets of $\{ 1, \dots, x\}$ is there a more natural element of saying this?  Here's some examples:
$$ \Big\{ \{ 5, 10, 15, 20, 25\}, \{ 73, 74, 75, 76, 77 \}, \{ 30, 40, 50, 60, 70 \} \Big\}  \subseteq \Big\{ \mathbf{5} \to \{ 1, \dots , 10^2 \} \Big\} $$
The we are defining a $\times$-like function $\times: \{ \text{subsets} \} \to \mathbb{Z}$.  Using a quick computer search here's nice example:
$$ \big| \sqrt{21 \times 31 \times 71 \times 74 \times 79 } - 16438 \big| < 10^{-2}$$
This requires us to have a \textbf{metric} on $\mathbb{Q}$ that completes to $\mathbb{R}$ (or to some other interesting topological space!) Let's roll the dice again:
$$ \sqrt{44 \times 119 \times 132 \times 153 \times 189} = 141372 + \mathbf{0} $$
This is accurate to all decimal places.  Our most basic example of a profinite group is $\mathbb{R}$ itself.  Why could the decimal systmem with carries matter so much?
$$ \sqrt{28 \times 30 \times 42 \times 49 \times 180} = 17640 + \mathbf{0} $$
Exact results again.  Are three decimal places sufficient for the problem we just described?  No.
$$ \Big| \sqrt{14 \times 59 \times 109 \times 197 \times 198} - 59261 \Big| < 10^{-3} $$
so with a computer we can somehow get a nice approximate result.  All of our work is hidden in the computer program itself. 
\begin{verbatim}
import numpy as np

N = 200
n = np.arange(N) + 1

for t in range(10000):
    # this method doesn't ensure DISTINCT random integers
    m = n[ (N*(np.random.random(5))).astype(int)]
    y = np.product(m)
    if (y**0.5 % 1) < 0.001:
        if (y**0.5 % 1) > 0:
            print(m, y, y**0.5)
\end{verbatim}
So we have yet to look under the hood.  In some cases, merely checking for prime numbers -- I have yet to specify how we decided a number was a perfect square.  E.g. 
$$ 3511866204 \in \square $$
Really the test for squares in $\mathbb{Z}$ is to check that $n/p^2 \in \mathbb{Z}$ and yet $n/p \notin \mathbb{Z}$.  How do we tell our computer to do the times tables? How does our computer even know what decimal digits are? \\ \\ Even if we do all that, how much heat are we generating getting these results?  So we could let $N = 10^{100}$ and we have to decide how much integers there is to get a perfect square. \\ \\
\textbf{Bonus} We need all these fabulous examples of numbers:
$$ \big| \sqrt{2 \times 87 \times 159 \times 188 \times 212 \times 221} - 7929139 \big| < 10^{-4} $$
Professional hints: one the authors is specialist in {\color{ blue}\textbf{random graph theory}} and {\color{blue}\textbf{functional analysis}}}.  So why are things so bad?  It's just that we are consuming more and more paper trying to get exact multiplication results out of large numbers.  Any time we did an approximation -- settled for a ``close" result -- any time we made a choice of algorithms we could have done ten other ways.  It's OK.

\newpage

{ \fontsize{16pt}{16pt} \selectfont

\noindent \textbf{05/18} Let's find an example with 4-digit numbers:
$$ \sqrt{1071 \times 2626 \times 3491 \times 3699 \times 4555\times 8181 \times 8298 } \in \mathbb{Z}  $$
It looks like the answer is $\sqrt{\dots} = 1224323517$.  This result is \textbf{false}.  What does that mean?  What's so bad about this result?  Depending on how we measure it, this result could be acceptable.
$$ \Big|  \sqrt{1071 \times 2626 \times 3491 \times 3699 \times 4555\times 8181 \times 8298 } - 1224323517 \Big| <  1 \times 10^{-4} $$
We also have error in the other direction.  The mistakes are consistently at least this big.
$$ \Big|  \sqrt{1071 \times 2626 \times 3491 \times 3699 \times 4555\times 8181 \times 8298 } - 1224323517 \Big| >  7 \times 10^{-5}$$
With a computing machine of some kind (in this case, just a laptop -- a pocket calculator could also suffice), meaningful \textit{highly non-trivial} example of numbers \textit{approximately} in $\square$ can be generated.  \\ \\
Numbers are mostly shorthands or representations of physical ideas or concepts or observations. Even symbols like ``$<$" and ``$>$" need to be reviewed.
\begin{itemize}
\item  How much work is the computer doing to generate these examples?
\item  How do we know the computer is not lying to us?
\item The typical program (e.g. solve $a \times b$) asks for resources like this:
\begin{itemize}
\item we have a bunch of $5$-digit numbers
\item we need $1000$ additions
\item we need $3000$ multiplications
\end{itemize}
Then we get a result.  What did the steps in the middle look like?
\item What's the difference between a result thatÂ´s ``close enough" and an outright ``lie".  Solving a problem can be used to lie in other settings.  
\end{itemize}  

\begin{verbatim}
RuntimeWarning: invalid value encountered in power
  if (y**0.5 % 1) < 0.0001:
untimeWarning: invalid value encountered in double_scalars
  if (y**0.5 % 1) < 0.0001:

\end{verbatim}
So we are approaching needle-in-haystack territory and yet the computer finds the examples just fine.  The computing machine or collection of machines that produce a result together.
$$ \Big| \sqrt{ 1940 \times 2001 \times 2287 \times 4189 \times 4441 \times 6699 \times 8162 } - 2671434353 \Big| < 10^{-6} $$
This is a \$1000000 result (not really).  The error message says we're running out of space doing our computation. 

\newpage 

How much space are we using with these numbers $713 6561 5023 8854 5640 < 10^{20}$ so we needed this number to be exact to 20 decimal place.  We are sure this problem has some slack somewhere, yet the usual places don't work.  
\begin{itemize}
\item Can we benefit from our failed attempts to solve the problem?
\item If we complain the result is not exact, describe the [opposite of exact]
\item What if we run out of space resources or time resources in the middle of the problem?
\end{itemize}
Our search for solutions is example of \textbf{martingale} problem.  We criterion for solution which is difficult to solve exactly, so we randomly search for solutions and stop when our solution is close enough. \\ \\
Let's try this problem with complex numbers which are now called Gaussian integers.  
$$ \Big| \sqrt{(90 + 13i) \times (30 + 17i) \times (15 +92i) \times (85 + 46i) \times (32 + 37i)} - \big(  \big) \Big| < 10^{-2}  $$
When all we do take the answer, we throw away the wrapper, the shipping information and ton of valuable information.  The answer for now is 
\begin{eqnarray*} \sqrt{\dots} &\approx& 5194 + 36808i \\
\sqrt{\dots} & \in & 10^{-2} \{ |z| < 1 \} + \mathbb{Z}[i] 
\end{eqnarray*}
This shape is just a lattice with circles everywhere.  Number Theorists are so confident their examples work and they're dime-a-dozen that they might prefer to work abstractly or in coded fashion.


\noindent 
 
}
\vfill

\begin{thebibliography}{}

\item \dots

\end{thebibliography}
\end{document}